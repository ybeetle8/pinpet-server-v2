# 代码接口规范文档

## 1. 概述

本文档定义了基于 Rust + Axum 框架的 Web API 开发规范，包括响应结构、错误处理、文档生成、路由设计等核心标准。所有开发人员必须严格遵循本规范，以确保代码的一致性、可维护性和可扩展性。

### 1.1 技术栈

- **Web 框架**: Axum
- **ORM**: SeaORM
- **缓存**: Redis (deadpool-redis)
- **API 文档**: utoipa (OpenAPI 3.0)
- **序列化**: serde, serde_json
- **错误处理**: anyhow
- **日志**: tracing

---

## 2. API 响应结构规范

### 2.1 统一响应格式 (CommonResult)

所有 API 接口必须使用统一的响应结构 `CommonResult<T>`，确保前端能够以一致的方式处理响应。

#### 2.1.1 结构定义

```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct CommonResult<T: Serialize> {
    /// 响应状态码
    pub code: u32,
    /// 响应消息
    pub msg: String,
    /// 响应数据（成功时包含数据，失败时为 None）
    pub data: Option<T>,
}
```

#### 2.1.2 字段说明

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| `code` | `u32` | 是 | 响应状态码，200 表示成功，其他值表示错误 |
| `msg` | `String` | 是 | 响应消息，成功时为 "success"，错误时为具体错误信息 |
| `data` | `Option<T>` | 否 | 响应数据，成功时包含具体数据，失败时为 `null` |

#### 2.1.3 状态码规范

| 状态码 | HTTP Status | 含义 | 使用场景 |
|--------|-------------|------|----------|
| 200 | 200 OK | 成功 | 请求成功处理 |
| 400 | 200 OK | 请求错误 | 参数格式错误、业务规则验证失败 |
| 401 | 200 OK | 未授权 | Token 无效、Token 过期、未提供认证信息 |
| 404 | 200 OK | 资源不存在 | 请求的资源未找到 |
| 500 | 200 OK | 服务器错误 | 数据库错误、Redis 错误、内部系统错误 |

**注意**: 所有响应的 HTTP 状态码统一为 200 OK，真实的业务状态通过 `code` 字段传递。

#### 2.1.4 构造方法

```rust
impl<T: Serialize> CommonResult<T> {
    /// 自定义响应
    pub fn default(code: u32, msg: String, data: Option<T>) -> Self {
        CommonResult { code, msg, data }
    }

    /// 成功响应（带数据）
    pub fn ok(data: T) -> Self {
        Self::default(200, "success".to_string(), Some(data))
    }

    /// 错误响应（无数据）
    pub fn error(code: u32, msg: String) -> Self {
        Self::default(code, msg, None)
    }

    /// 直接返回错误响应
    pub fn error_response(code: u32, msg: String) -> Response {
        Self::error(code, msg).into_response()
    }
}
```

#### 2.1.5 响应示例

**成功响应（有数据）**
```json
{
  "code": 200,
  "msg": "success",
  "data": {
    "wallet": "0x1234567890abcdef",
    "build_status": true,
    "created_time": "2024-01-01T00:00:00"
  }
}
```

**成功响应（无数据）**
```json
{
  "code": 200,
  "msg": "success",
  "data": null
}
```

**错误响应**
```json
{
  "code": 401,
  "msg": "Unauthorized",
  "data": null
}
```

### 2.2 辅助响应函数

#### 2.2.1 `ok_result` - 处理 Result 类型

自动将 `Result<T, ApiError>` 转换为响应：

```rust
pub fn ok_result<T: Serialize>(result: Result<T, ApiError>) -> Response {
    match result {
        Ok(data) => CommonResult::ok(data).into_response(),
        Err(err) => err.into_response(),
    }
}
```

**使用场景**：Service 层返回 `Result<T, ApiError>` 时

```rust
pub async fn get_info(Extension(user): Extension<LoginUser>) -> ApiResult {
    Ok(ok_result(user_service::get_user_info(user.address()).await))
}
```

#### 2.2.2 `success_result` - 处理 Option 类型

自动将 `Option<T>` 转换为响应：

```rust
pub fn success_result<T: Serialize>(data: Option<T>) -> Response {
    match data {
        Some(d) => CommonResult::ok(d).into_response(),
        None => CommonResult::<T>::default(200, "success".to_string(), None).into_response(),
    }
}
```

**使用场景**：Service 层返回 `Option<T>` 时

---

## 3. 错误处理规范

### 3.1 ApiError 枚举定义

所有错误必须通过 `ApiError` 枚举进行统一处理：

```rust
#[derive(Debug)]
pub enum ApiError {
    /// 直接返回的响应
    Response(Response),
    /// Anyhow 错误
    AnyhowError(anyhow::Error),
    /// 数据库错误
    DbError(DbErr),
    /// Redis 连接池错误
    RedisError(PoolError),
    /// Redis 创建连接池错误
    RedisCreatePoolError(CreatePoolError),
    /// 请求错误
    BadRequest(String),
    /// 请求参数错误
    RequestParamError(String),
    /// JSON 解析错误
    JsonRejection(JsonRejection),
    /// IO 错误
    InternalError(std::io::Error),
    /// 未授权
    Unauthorized(String),
    /// 资源不存在
    NotFound(String),
    /// 业务错误
    BusinessError(String),
}
```

### 3.2 错误分类

#### 3.2.1 业务错误 (Business Error)

不需要堆栈跟踪的错误，由业务逻辑产生：

```rust
pub fn is_business_error(&self) -> bool {
    matches!(
        self,
        ApiError::Unauthorized(_) |
        ApiError::BadRequest(_) |
        ApiError::NotFound(_) |
        ApiError::BusinessError(_)
    )
}
```

**特点**：
- 不会打印堆栈信息
- 错误信息直接返回给前端
- 使用场景：用户输入错误、权限不足、资源不存在等

#### 3.2.2 系统错误 (System Error)

需要记录详细日志的错误：

```rust
pub fn is_system_error(&self) -> bool {
    !self.is_business_error()
}
```

**特点**：
- 会打印完整的错误堆栈
- 错误信息包含技术细节
- 使用场景：数据库错误、Redis 错误、IO 错误等

### 3.3 错误转换规范

#### 3.3.1 自动转换实现

所有常见错误类型必须实现 `From` trait，支持 `?` 运算符：

```rust
// 数据库错误转换
impl From<DbErr> for ApiError {
    fn from(e: DbErr) -> Self {
        error!("数据库错误: {:?}", e);
        Self::DbError(e)
    }
}

// Redis 错误转换
impl From<PoolError> for ApiError {
    fn from(e: PoolError) -> Self {
        error!("Redis错误: {:?}", e);
        Self::RedisError(e)
    }
}

// Anyhow 错误转换（使用 {:#} 格式化显示完整错误链）
impl From<anyhow::Error> for ApiError {
    fn from(e: anyhow::Error) -> Self {
        error!("anyhow错误：{:#}", e);
        Self::AnyhowError(e)
    }
}

// JSON 解析错误转换
impl From<JsonRejection> for ApiError {
    fn from(e: JsonRejection) -> Self {
        error!("Json参数格式错误：{:?}", e);
        Self::JsonRejection(e)
    }
}
```

#### 3.3.2 使用示例

```rust
pub async fn get_user(id: i64, db: &DbConn) -> Result<UserModel, ApiError> {
    // 数据库错误会自动转换为 ApiError::DbError
    let user = User::find_by_id(id).one(db).await?;

    // 手动返回业务错误
    user.ok_or(ApiError::NotFound("用户不存在".to_string()))
}
```

### 3.4 错误响应映射

```rust
impl IntoResponse for ApiError {
    fn into_response(self) -> Response {
        match self {
            Self::Response(resp) => resp,
            Self::NotFound(e) => error(404, format!("404错误：{e}")),
            Self::JsonRejection(e) => error(400, e.body_text()),
            Self::Unauthorized(e) => error(401, e),
            Self::BadRequest(e) => error(400, format!("请求错误：{e}")),
            Self::RequestParamError(e) => error(400, format!("参数错误：{e}")),
            Self::InternalError(e) => error(500, format!("内部错误：{e}")),
            Self::DbError(e) => error(500, format!("数据库错误：{e}")),
            Self::RedisError(e) => error(500, format!("Redis错误：{e}")),
            Self::RedisCreatePoolError(e) => error(500, format!("Redis Pool错误：{e}")),
            Self::BusinessError(e) => error(500, format!("业务错误：{e}")),
            Self::AnyhowError(e) => error(500, e.to_string()),
            _ => {
                error!("未知异常：[{}:{}]", file!(), line!());
                error(500, "未知错误".to_string())
            }
        }
    }
}
```

### 3.5 错误处理最佳实践

1. **使用 `?` 运算符**：让错误自动传播和转换
2. **业务错误使用具体变体**：如 `ApiError::Unauthorized`、`ApiError::NotFound`
3. **系统错误记录日志**：在 `From` 实现中使用 `error!` 宏
4. **错误消息国际化**：业务错误消息应支持多语言

---

## 4. API 文档规范 (OpenAPI/Swagger)

### 4.1 文档结构

使用 `utoipa` 库生成符合 OpenAPI 3.0 标准的文档。

#### 4.1.1 全局文档配置

```rust
#[derive(OpenApi)]
#[openapi(
    paths(
        // 路由函数列表
        auth::auth,
        user::get_info,
    ),
    components(
        schemas(
            // 请求/响应结构体列表
            AuthRequest,
            UserInfoResponse,
            ErrorApiResponse,
        )
    ),
    tags(
        (name = "auth", description = "认证相关接口"),
        (name = "user", description = "用户相关接口"),
    ),
)]
pub struct ApiDoc;
```

### 4.2 响应结构体规范

#### 4.2.1 通用响应结构体 (ApiResponse)

用于 Swagger 文档中的泛型响应：

```rust
#[derive(Debug, Serialize, Deserialize, ToSchema)]
#[schema(title = "ApiResponse", description = "API 统一响应格式")]
pub struct ApiResponse<T>
where T: ToSchema + Serialize
{
    /// 响应状态码：200=成功，其他=错误
    #[schema(example = 200)]
    pub code: u32,

    /// 响应消息
    #[schema(example = "success")]
    pub msg: String,

    /// 响应数据，成功时包含具体数据，失败时为 null
    pub data: Option<T>,
}
```

#### 4.2.2 空响应结构体 (EmptyResponse)

用于没有返回数据的接口：

```rust
#[derive(Debug, Serialize, Deserialize, ToSchema)]
#[schema(
    title = "EmptyResponse",
    description = "空数据响应格式（操作成功但无返回数据）",
    example = json!({
        "code": 200,
        "msg": "success",
        "data": null
    })
)]
pub struct EmptyResponse {
    #[schema(example = 200)]
    pub code: u32,

    #[schema(example = "success")]
    pub msg: String,

    pub data: Option<()>,
}
```

#### 4.2.3 错误响应结构体 (ErrorApiResponse)

用于错误响应的文档：

```rust
#[derive(Debug, Serialize, Deserialize, ToSchema)]
#[schema(title = "ErrorApiResponse", description = "错误响应格式")]
pub struct ErrorApiResponse {
    /// 响应状态码：非200表示错误
    pub code: u32,

    /// 错误消息
    pub msg: String,

    /// 错误时数据为空
    pub data: Option<Value>,
}
```

### 4.3 接口文档注解规范

#### 4.3.1 完整示例

```rust
#[utoipa::path(
    get,
    path = "/user/get_info",
    tag = "user",
    summary = "获取用户信息",
    description = "获取当前用户的详细信息，包括钱包地址、构建状态等。需要 JWT 认证。",
    responses(
        (status = 200, description = "获取用户信息成功",
         body = crate::docs::ApiResponse<UserInfoResponse>),
        (status = 401, description = "未授权",
         body = crate::docs::ErrorApiResponse,
         example = json!({
             "code": 401,
             "msg": "Unauthorized",
             "data": null
         })
        ),
        (status = 500, description = "服务器内部错误",
         body = crate::docs::ErrorApiResponse,
         example = json!({
             "code": 500,
             "msg": "Internal Server Error",
             "data": null
         })
        )
    ),
    security(
        ("Authorization" = [])
    )
)]
pub async fn get_info(
    State(state): State<ServerState>,
    Extension(user): Extension<LoginUser>
) -> ApiResult {
    Ok(ok_result(
        user_service::get_user_info(
            user.address(),
            user.lang(),
            state.db(),
            state.i18n()
        ).await
    ))
}
```

#### 4.3.2 注解字段说明

| 字段 | 必填 | 说明 |
|------|------|------|
| `method` | 是 | HTTP 方法：get, post, put, delete 等 |
| `path` | 是 | 完整的 API 路径 |
| `tag` | 是 | 接口分组标签 |
| `summary` | 是 | 接口简短描述（一句话） |
| `description` | 是 | 接口详细说明 |
| `responses` | 是 | 所有可能的响应状态 |
| `security` | 视情况 | 需要认证时必须添加 |
| `request_body` | 视情况 | POST/PUT 请求时必须添加 |

### 4.4 数据模型文档规范

#### 4.4.1 完整示例

```rust
#[derive(Debug, Serialize, Deserialize, Getters, Setters, TypedBuilder, ToSchema)]
#[getset(set = "pub", get = "pub")]
#[schema(
    title = "UserInfoResponse",
    description = "用户信息响应数据结构",
    example = json!({
        "wallet": "0x1234567890abcdef",
        "build_status": true,
        "created_time": "2024-01-01T00:00:00"
    })
)]
pub struct UserInfoResponse {
    /// 用户钱包地址，用户的以太坊钱包地址
    #[schema(example = "0x1234567890abcdef")]
    wallet: String,

    /// 构建状态，用户的构建状态，true 表示已构建，false 表示未构建
    #[schema(example = true)]
    build_status: bool,

    /// 创建时间，用户账户创建时间
    #[schema(example = "2024-01-01T00:00:00", value_type = String)]
    created_time: NaiveDateTime,
}
```

#### 4.4.2 字段注解规范

- **必须添加字段级文档注释**：使用 `///` 注释
- **必须添加 `#[schema(example = ...)]`**：提供示例值
- **特殊类型需要 `value_type`**：如 `NaiveDateTime` 需要指定为 `String`
- **结构体级别必须添加 `example`**：展示完整的 JSON 示例

### 4.5 认证配置

#### 4.5.1 全局安全配置

```rust
use framework_starter_web::SecurityAddon;

// 创建带有认证白名单的 SecurityAddon
let security_addon = SecurityAddon::default_with_auth_whitelist(
    vec!["/auth/login".to_string()]
);
security_addon.modify(&mut openapi);
```

#### 4.5.2 接口级认证

```rust
#[utoipa::path(
    // ...
    security(
        ("Authorization" = [])
    )
)]
```

**规范**：
- 不需要认证的接口（如登录）加入白名单
- 需要认证的接口必须添加 `security` 注解
- Authorization Header 格式：`Bearer <token>`

---

## 5. 路由设计规范

### 5.1 路由函数定义

```rust
pub fn routes() -> Router<ServerState> {
    Router::new()
        .route("/user/get_info", get(get_info))
        .route("/user/test", get(test))
}
```

### 5.2 路由命名规范

| 操作 | HTTP 方法 | 路径格式 | 示例 |
|------|----------|----------|------|
| 获取列表 | GET | `/{resource}/list` | `/user/list` |
| 获取单个 | GET | `/{resource}/get_info` 或 `/{resource}/{id}` | `/user/get_info` |
| 创建 | POST | `/{resource}/create` | `/user/create` |
| 更新 | PUT/POST | `/{resource}/update` | `/user/update` |
| 删除 | DELETE/POST | `/{resource}/delete` | `/user/delete` |
| 自定义操作 | POST | `/{resource}/{action}` | `/user/reset_password` |

### 5.3 RESTful vs RPC 风格

本规范支持两种 API 风格：

#### 5.3.1 RESTful API

- 面向资源设计
- 使用 HTTP 方法表达操作
- 路径表示资源层级

#### 5.3.2 RPC API

- 面向动作设计
- 路径表示操作
- 适合复杂业务逻辑

**建议**：优先使用 RESTful，复杂操作使用 RPC。

---

## 6. Handler 层规范

### 6.1 Handler 函数签名

```rust
pub async fn handler_name(
    State(state): State<ServerState>,          // 应用状态
    Extension(user): Extension<LoginUser>,      // 认证用户（可选）
    Json(req): Json<RequestType>,               // 请求体（可选）
) -> ApiResult {
    // 调用 Service 层
    Ok(ok_result(
        service::method(params).await
    ))
}
```

### 6.2 参数提取顺序

1. `State` - 应用状态、数据库连接等
2. `Extension` - 中间件注入的数据（如认证用户）
3. `Path` - 路径参数
4. `Query` - 查询参数
5. `Json` - 请求体

### 6.3 Handler 层职责

- **仅负责参数提取和响应转换**
- **不包含业务逻辑**
- **调用 Service 层方法**
- **使用 `ok_result` 或 `success_result` 转换响应**

### 6.4 完整示例

```rust
#[utoipa::path(
    get,
    path = "/user/get_info",
    tag = "user",
    summary = "获取用户信息",
    description = "获取当前用户的详细信息",
    responses(
        (status = 200, description = "成功",
         body = crate::docs::ApiResponse<UserInfoResponse>),
        (status = 401, description = "未授权",
         body = crate::docs::ErrorApiResponse)
    ),
    security(("Authorization" = []))
)]
pub async fn get_info(
    State(state): State<ServerState>,
    Extension(user): Extension<LoginUser>,
) -> ApiResult {
    Ok(ok_result(
        user_service::get_user_info(
            user.address(),
            user.lang(),
            state.db(),
            state.i18n()
        ).await
    ))
}
```

---

## 7. Service 层规范

### 7.1 返回类型规范

Service 层函数必须返回 `Result<T, ApiError>`：

```rust
pub async fn get_user_info(
    address: &str,
    lang: &str,
    db: &DbConn,
    i18n: &I18n,
) -> Result<UserInfoResponse, ApiError> {
    // 业务逻辑
    let user = User::find_by_wallet(address, db).await?;

    // 转换为响应对象
    Ok(UserInfoResponse::from(user))
}
```

### 7.2 错误处理

```rust
// 使用 ? 自动转换系统错误
let user = User::find_by_id(id, db).await?;

// 手动返回业务错误
if user.is_none() {
    return Err(ApiError::NotFound("用户不存在".to_string()));
}

// 使用 ok_or 简化
let user = user.ok_or(ApiError::NotFound("用户不存在".to_string()))?;
```

### 7.3 Service 层职责

- 实现所有业务逻辑
- 调用 Repository/DAO 层
- 数据转换和验证
- 事务管理
- 缓存处理

---

## 8. 数据转换规范

### 8.1 Entity -> Response

使用 `From` trait 实现实体到响应的转换：

```rust
impl From<qt_user::Model> for UserInfoResponse {
    fn from(user_info: qt_user::Model) -> Self {
        UserInfoResponse::builder()
            .wallet(user_info.wallet_address)
            .build_status(true)
            .created_time(user_info.create_time)
            .build()
    }
}
```

### 8.2 Request -> Entity

手动转换或使用 `Into` trait：

```rust
impl CreateUserRequest {
    pub fn to_entity(self) -> qt_user::ActiveModel {
        qt_user::ActiveModel {
            wallet_address: Set(self.wallet),
            // ...
        }
    }
}
```

### 8.3 使用 TypedBuilder

推荐使用 `typed-builder` 创建复杂对象：

```rust
#[derive(TypedBuilder)]
pub struct UserInfoResponse {
    wallet: String,
    build_status: bool,
    created_time: NaiveDateTime,
}

// 使用
let response = UserInfoResponse::builder()
    .wallet("0x...".to_string())
    .build_status(true)
    .created_time(now)
    .build();
```

---

## 9. 代码组织结构

### 9.1 推荐目录结构

```
src/
├── framework/           # 框架配置
│   ├── config/         # 配置文件
│   └── middleware/     # 中间件
├── router/             # 路由定义
│   ├── api/           # REST API 路由
│   └── rpc/           # RPC 路由
├── handler/            # Handler 层（可选，简单项目可直接在 router 中定义）
├── services/           # Service 层（业务逻辑）
├── repository/         # Repository 层（数据访问）
├── entity/             # 数据库实体（SeaORM 生成）
├── request/            # 请求结构体
├── response/           # 响应结构体
├── util/               # 工具函数
│   ├── result.rs      # CommonResult、ApiError
│   └── ...
├── docs/               # API 文档相关
│   └── mod.rs         # OpenAPI 配置
└── main.rs
```

### 9.2 模块命名规范

- 使用 `snake_case` 命名文件和模块
- 使用 `PascalCase` 命名结构体和枚举
- 使用 `snake_case` 命名函数和变量
- 使用 `SCREAMING_SNAKE_CASE` 命名常量

---

## 10. 依赖管理规范

### 10.1 必需依赖

```toml
[dependencies]
# Web 框架
axum = { version = "0.7", features = ["macros"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "trace"] }

# 序列化
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# 数据库
sea-orm = { version = "0.12", features = ["runtime-tokio-native-tls", "sqlx-mysql"] }

# Redis
deadpool-redis = "0.14"

# 错误处理
anyhow = "1.0"
thiserror = "1.0"

# API 文档
utoipa = { version = "4.0", features = ["axum_extras"] }
utoipa-swagger-ui = { version = "6.0", features = ["axum"] }

# 工具库
getset = "0.1"
typed-builder = "0.18"

# 日志
tracing = "0.1"
tracing-subscriber = "0.3"

# 异步运行时
tokio = { version = "1", features = ["full"] }
```

---

## 11. 最佳实践总结

### 11.1 DO（应该做）

1. ✅ 所有接口使用 `CommonResult<T>` 统一响应格式
2. ✅ 使用 `ApiError` 枚举统一错误处理
3. ✅ 为所有接口添加完整的 `utoipa` 文档注解
4. ✅ 业务逻辑放在 Service 层，Handler 层仅做参数提取
5. ✅ 使用 `?` 运算符传播错误
6. ✅ 系统错误记录详细日志
7. ✅ 数据转换使用 `From`/`Into` trait
8. ✅ 使用 `TypedBuilder` 构建复杂对象
9. ✅ 认证接口添加白名单配置
10. ✅ 响应结构体提供完整的示例数据

### 11.2 DON'T（不应该做）

1. ❌ 直接返回 `String` 或其他非标准格式
2. ❌ 使用不同的错误处理方式
3. ❌ 省略 API 文档注解
4. ❌ 在 Handler 层编写业务逻辑
5. ❌ 使用 `unwrap()` 或 `expect()`（除非确定不会 panic）
6. ❌ 忽略错误日志
7. ❌ 硬编码业务逻辑
8. ❌ 直接暴露数据库实体作为响应
9. ❌ 所有接口都要求认证（登录接口例外）
10. ❌ HTTP 状态码携带业务状态（统一返回 200，用 code 字段表示业务状态）

---

## 12. 检查清单

新接口开发完成后，请检查以下项目：

- [ ] 响应格式使用 `CommonResult<T>`
- [ ] 错误处理使用 `ApiError` 枚举
- [ ] 添加完整的 `#[utoipa::path]` 注解
- [ ] 响应结构体实现 `ToSchema` 并添加 `example`
- [ ] 所有字段添加文档注释和示例值
- [ ] 需要认证的接口添加 `security` 注解
- [ ] Handler 层仅做参数提取，不包含业务逻辑
- [ ] Service 层返回 `Result<T, ApiError>`
- [ ] 数据转换使用 `From`/`Into` trait
- [ ] 路由命名符合规范
- [ ] 系统错误记录日志
- [ ] 业务错误提供清晰的错误消息
- [ ] 测试 Swagger UI 文档正常显示
- [ ] 测试成功和失败场景

---

## 13. 版本历史

| 版本 | 日期 | 作者 | 说明 |
|------|------|------|------|
| 1.0.0 | 2024-01-01 | - | 初始版本 |

---

## 14. 参考资料

- [Axum 官方文档](https://docs.rs/axum/)
- [utoipa 官方文档](https://docs.rs/utoipa/)
- [SeaORM 官方文档](https://www.sea-ql.org/SeaORM/)
- [OpenAPI 3.0 规范](https://swagger.io/specification/)
